1.Why the energy consuming is more important for mobile device than for desktops?Because the most advantage of the mobile device compare with the desktops is the mobiledevice is mobility and convenient. When we use desktops it is suitable when we are working on desktops we also charge the laptop. But it is not fine when we need use the mobile device, the mobile device show the battery is low. The most important function of mobile device compare with the desktops is mobility.2.Why the security in mobile system is more complicated than that in desktop systems?The occur of repackaging technology make build the virus automatic become possible. Inaddition, the Smali, one of Dalvik assembly tools occur make people much more easily to automatic confusion and exchange the binary code of Android. Next, the user of mobile device are not used to download the software in the official place, it will also make the security problem become much more complex compare with the desktops. And also many mobile device user are like to using iOS jailbreaking or Refurbishment, it will also increase the difficult to make sure the system is secure.3.What is the difference between app and application?As far as I concerned the most important different between the App and the Application is thedesign purpose for App is much more single compare with the Application. Due to this, the function of App will be much more less than the Application. In addition, the app will be much more smaller than the Application. In App sides, the less is more. The application will performs a lot of functions, in some people side, the application will looks little complicated overwhelming, the App will be more succinct. In addition, the duration of updated for App will shorter than the application.4. What is Dalvik? What is the difference between Dalvik and traditional JVM?The Dalvik is designed by Google which is a process virtual machine for Android operatingsystem which is different with the JVM. The different between the Dalvik and the traditional JVM is the Dalvik is register based and the JVM is stack based. The advantage for register based virtual machine is the perform speed will quick than the stack based JVM. The disadvantage for register based is it will have longer code to performs same function. In addition, the Dalvik allow multiple instance. Every Dalvik's virtual machine is one process for Linux kernel. Next, the Dalvik Virtual Machine will compiler the .java file to .class file, and then reuild the .class file and finally compress and writer into a .dex file rather than produce a .jar file.5.Is SJF optimal in multiple processor? Considering the average time and the total completion time. Please prove your point.For multiple process, in the total completion time and average completion time sides we can say the SJF are optimal. For example, if we have T k jobs and we have totally n processor, the time from T1 to Tk is increased. The totally completiont=k(T1+T2+...+Tn)+k−n(Tn+1+Tn+2+...+T2n)+...+(Tk−n+1+Tk−n+2+...+Tk−n+n) you can see nnthe T 1 , T 2 , ... , T n has the biggest factor, the value of totally completion time will be mostly depend on the T1 ,T2 ,...,Tn . And the way to calculate the average completion time is totallycompletion time divided by k, k is constant number, the average completion time is depend on the totally completion time. If one algorithm has the least totally completion time it should also have the least average completion time. For SJF it choose the shortest job as the T1 ,T2 ,...,Tn , so SJF has the least T1 ,T2 ,...,Tn , according to the totally completion time is mostly based on theT1 ,T2 ,...,Tn , so we can see the SJF has the shortest totally completion time. The average completion time is linear relative to the totally completion time, so the SJF also has the shortestaverage completion time. In the totally completion time and average completion time side, we can say the SJF are the optimal in multiple processor.
valgrind --leak-check=yes ./mdb-lookup-server-nc-2valgrind --leak-check=yes ./mdb-lookup-server-nc-2
1.	Use the app you developed or you used before to explain your understanding of activity:As far as I concerned, the activity is much more like the UI sides. The activity is a single screen with a user interface. Every activity is an independent class and it is extending Activity. The activity could have some UI and also could listen to the user performance for example as onClick Listener. For example, one very important function for activity is to show the view and have interact with the user. 2.	Use the app you developed or you used before to explain your understanding of service.The service is a component which is running in the background, and it could perform long-running operations and it could perform works for remote process. One different between service and activity is service didn’t provide UI. One function the service could be used is connect to the server to receive message from serve or it could use to play music. 3.	Use the app you developed or you used before to explain your understanding of content provider.Content provider could manage a shared set of app data. By using content provider, different App could share the data. The content provider could interact with file system. SQLite, web, and all storage location app can access. By using content provider, it could allow app to query or modify the data. One example the content provider could be used is Facebook could read your contact information after you give access. 4.	Use the app you developed or you used before to explain your understanding of intent.The intent is a mechanism for describing a specific action, all the information and everything is go through intents. By using intent, app can start another app’s component such as activity or service. By using intent, it could deliver a message, and system will specify the intent and then start the component. The intent was much more used to transfer information between different component in app. Such as you click on button, want to go another UI, it will send an intent to start the relative activity.CSEE 4119: Computer Networks, Fall 2015 Programming Assignment 2: Simple TCP­like transport­layer protocol Due Friday, November 6​th​ 11:55 pmAcademic Honesty PolicyYou are permitted and encouraged to help each other through Piazza's web board. This only means that you can discuss and understand concepts learnt in class. However, you may NOT share source code or hard copies of source code. Refrain from sharing any material that could cause your source code to APPEAR TO BE similar to another student's source code enrolled in this or previous years. Refrain from getting any code off the Internet. Cheating will be dealt with severely. Cheaters will be penalized. Source code should be yours and yours only. Do not cheat.1. IntroductionIn this programming assignment, you will implement a simplified TCP­like transport layer protocol. Your protocol should provide reliable, in order delivery of a stream of bytes. It should recover from in­network packet loss, packet corruption, packet duplication and packet reordering and should be able cope with dynamic network delays. However, it doesn’t need to support congestion or flow control.To test your implementation you will use a link emulator provided by us (see proxy.zip under Programming Assignment 2; contains a README that guides usage). Data is exchanged via UDP, i.e., you will be running your TCP version "on top of" UDP. In the real­world, a network can drop, corrupt, reorder, duplicate and delay packets. To mimic this behavior you will use the link emulator. Specifically, you will invoke the emulator so that it lies in the sender­to­receiver path, whereas the acknowledgements (i.e., the packets on the receiver­to sender path) will be sent directly from the receiver to the sender, i.e., you can assume that packets arrive without a loss on this path.
You can run your sender, receiver and link emulator either on one, two or three machines. The link emulator acts like a "proxy", i.e., the sender sends packets towards the emulator and the emulator should forward the packets to the receiver. The receiver process should send its acknowledgements directly to the data sender.This programming assignment can be implemented in either of the following two ways.a) As a stand­alone independent implementation.b) ​As an extension to the Programming Assignment 1. (This will be considered only for extra credit)You can use either C, C++, Java or Python your implementation, using standard UNIX or Java datagram socket calls (for brevity we refer only to UNIX network APIs in the assignment description).2. Usage scenario and functionality requirementsYou will implement a one­way ("simplex") version of TCP. Your program has to handle only one set of packets, i.e., the delivery of a single file. Your implementation will be composed of two separate programs, sender and receiver. The sender reads data from a file and uses the sending services of the TCP­like protocol to deliver it to the remote host. The receiver uses the receiving services of the TCP­like protocol to reconstruct the file.The TCP receiver should be invoked as follows:receiver <filename> <listening_port> <sender_IP> <sender_port> <log_filename>%receiver file.txt 20000 128.59.15.37 20001 logfile.txtDelivery completed successfully%The receiver receives data on the listening_port, writes it to the specified file (filename) and sends ACKs to the remote host at IP address (sender_IP) and port number (sender_port). In
the above example the ACKs are sent to the sender (128.59.15.37) with an ACK port 20001. The IP address is given in dotted­decimal notation and the port number is an integer value. The receiver will log the headers of all the received and sent packets to a log file (log_filename) specified in the command­line. The log entries should be ordered according to the timestamps of the packets, from lowest to highest, and should be displayed to the standard output if the specified log filename is “stdout”. The output format of a log entry should be as follows.timestamp, source, destination, Sequence #, ACK #, and the flagsThe receiver should indicate whether the reception was successful, and report file I/O errors(e.g., ‘unable to create file’).The data sender should be invoked as follows:% sender <filename> <remote_IP> <remote_port> <ack_port_num> <log_filename> <window_size> % sender file.txt 128.59.15.38 20000 20001 logfile.txt 1152Delivery completed successfullyTotal bytes sent = 1152Segments sent = 2Segments retransmitted = 0 %The sender sends the data in the specified file (filename) to the remote host at the specified IP address (remote_IP) and port number (remote_port). In the above example the remote host (which can be either the receiver or the link emulator proxy) is located at 128.59.15.38 and port 20000. The command­line parameter ack_port_num specifies the local port for the received acknowledgements.As before a log filename is specified. The log entry output format should be similar to the one used by the receiver, however, it should have one additional output field (append at the end), which is the estimated RTT. At the end of the delivery the sender should indicate whether the transmission was successful, and print the number of sent and retransmitted segments. The sender should report file I/O errors (e.g., ‘file not found’).The window_size is a parameter and window_size is measured in terms of the number of packets. Your sender should support variable window size, and it will be specified as the last parameter on command line. If no parameter is specified, the default window size value should be 1.
3.​ ​Requirements:●● ● ●● ●● ●4. Tips●●● ● ●You will implement a one­way version of TCP without the initial connection establishment, but with a FIN request to signal the end of the transmission.Sequence numbers should start from zero.You do not have to worry about congestion or flow controlYou should adjust your retransmission timer as per the TCP standard (although it may be advisable to use a fixed value for initial experimentation)You need to implement the 20­byte TCP header format, without options.You do not have to implement push (PSH flag), urgent data (URG), reset (RST) orTCP options.You should set the port numbers in the packet to the right values, but can otherwiseignore them.The TCP checksum is computed over the TCP header and data; this does not quitecorrespond to the correct way of doing it (which includes parts of the IP header), but is close enough.You should test your programs with and without the link emulator. When using the link emulator, specify its IP address and port number in the command line of the data sender.The link emulator can be run on UNIX/Linux vm (on Oracle VirtualBox or any virtual environment of your choice).​Test your program over a wide range of network settings.​Use file diff on the sent file and the received file to check if they are the same. ​You can choose a reasonable value for the maximum segment size, e.g., 576.
5. Submission guidelinesSubmission will be done by courseworks. Please post a single <UNI>_<Language>.zip (Ex. zz1111_java.zip) file to the Programming Assignment 2 folder. The file should include the following:● README.txt. This file contains the project documentation; program features and usage scenarios; a brief description of (a) the TCP segment structure used (b) the states typically visited by a sender and receiver (c) the loss recovery mechanism; and a description of whatever is unusual about your implementation, such as additional features or a list of any known bugs.● If you are extending your existing project, then your server will need to implement one more command called “GET”, and this will indicate the start of the file transfer. The first assignment command line will need to be modified to accept new arguments. Mention the new command line arguments usage clearly in the README.● For this assignment, assume that there is only one sender and one receiver for your file transfer.● Do not change the sequence/syntax of the input ​parametes on command line. And also provide sample command line arguments (for sender and receiver) in README.● TA's will compile and test the code you submit ​on CLIC machines​. It is your responsibility to make sure your code is able to be compiled and runnable on CLIC machines.The ​CLIC lab has following setup: Java 1.6, gcc version 4.6.3, python 2.7.3Testing point scheme:IssueDeductions1Compilation and Execution relatedCompilation fails­100Sender not invoked in given fomat­5Receiver not invoked in given fomat­5No easy to read documentation / make file­3
2FunctionalityIn order delivery not handled­10Packet loss not handled­10Corrupted packets not handled­10Packet delays not handled­10Duplicate packets not handled­10Log file not maintained on sender side­5Log file not maintained on receiver side­5Log file on sender does not follow given format­5Log file on receiver does not follow given format­5Statistics on sender is not printed properly­5File on receiver is different than what sender sent­10Variable window size supported­10Any errors in above functions­1 to ­15 per error (TA discretion)3Extra featuresMax +20Upto 10 points per extra feature (on TA discretion)References●● ●‘Computer Networking: A Top­Down Approach Featuring the Internet’ (3rd Edition) by James F. Kurose and Keith W. Ross. See Chapter 3 for a good description of transport­layer protocol fundamentals (with TCP as an illustrative example).‘TCP/IP Illustarted Vol I’ by W. Richard Stevens. An excellent guide to the TCP/IP protocol.‘Beej's Guide’ which can be found at http://www.beej.us/guide/bgnet/. An online tutorial for socket programming.
● Unix man pages for socket, bind, sendto, recvfrom. ● Proxy references:○ READMEhttp://www.cs.columbia.edu/~hgs/research/projects/newudpl/newudpl­1.4/newudpl.html ○ http://www.cs.columbia.edu/~hgs/research/projects/newudpl/
